<!DOCTYPE html>
<!-- Taken in modified form from https://potassco.org/clingo/run/ -->
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Student project ideas</title>

  <link rel="stylesheet" href="css/main.css">
</head>

<body>

  <main class="page-content" aria-label="Content">
    <div class="wrapper">
      <article class="post">

        <header class="post-header">
          <h1 class="post-title">Student project ideas</h1>
        </header>

        <div class="post-content">
          <div class="center">

            <p>Below are several ideas that can form the starting point for a student research project that I would be happy (and capable) to supervise. These ideas all have a reasonably concrete research question as starting point, and they are (likely) feasible to carry out.</p>

            <p>These projects are suitable for, for example, an small research project or a thesis project (in the context of the <a href="https://msclogic.illc.uva.nl/">MSc Logic</a> or the <a href="https://www.uva.nl/shared-content/programmas/en/masters/artificial-intelligence/artificial-intelligence.html">MSc Artificial Intelligence</a> at the <a href="https://www.uva.nl/">UvA</a>).</p>

            <p>Please <a href="mailto:me@ronalddehaan.eu">get in touch</a> with me (<a href="https://staff.science.uva.nl/r.dehaan/">Ronald de Haan</a>) if you are interested in any of these projects, or if you have questions about any of them.</p>

            <p>&nbsp;</p>

            <h3>1. Developing a reasoning algorithm for BSML</h3>
            <a name="bsml-reasoning"></a>

            <p><a href="https://arxiv.org/pdf/2305.11777">Bilateral state-based modal logic (BSML)</a> is a modal logic that has been used, for example, in <a href="https://semprag.org/index.php/sp/article/view/sp.15.5">recent work</a> by colleagues on pragmatics.</p>

            <p>I have built a (rough) <a href="https://github.com/rdehaan/bsml-sat/blob/main/demo.ipynb">prototype</a> for a reasoning algorithm for BSML that is based on answer set programming. This prototype can reason about small formulas in a reasonable amount of time. In terms of how well this algorithm (and variants of it) scales to larger formulas, much remains to be explored.</p>

            <p>There are a lot of directions for improving this reasoner, and many of them are very much suitable for a small research project or a thesis. For some suggestions for research directions, see <a href="https://github.com/rdehaan/bsml-sat/blob/main/demo.ipynb">the demonstration</a> of the prototype.</p>

            <ul>
              <li>The project requires a solid understanding of answer set programming. Students that have taken the course <i>Knowledge Representation and Reasoning</i> at the UvA are well prepared for this.</li>
              <li>The project also requires a basic understanding of modal logic.</li>
              <li>The project is algorithmic in nature, and involves some programming in Python.</li>
            </ul>

            <p>&nbsp;</p>

            <h3>2. Testing a declarative method to specify CEGAR-algorithms</h3>
            <a name="declarative-cegar"></a>

            <p>Counterexample-guided Abstraction Refinement (CEGAR) algorithms often provide a productive method for solving problems at higher levels of the Polynomial Hierarchy (PH). In the context of SAT solving or answer set solving (for problems at the second level of the PH), this type of algorithm typically looks as follows. One solver is given an encoding of candidate solutions to the problem (the <i>abstraction</i>), and it starts the search process and iterates over candidate solutions. There is a second solver that is running, which is given an encoding that expresses what counterexamples for candidate solutions should satisfy. Each candidate solution produced by the first solver is given to the second solver, in the form of assumptions. If the second solver does not find a counterexample, the candidate solution is returned as an actual solution. If the second solver does find a counterexample, this counterexample is used to produce a new constraint (a <i>refinement</i>) that is added to the first solver, and the first solver's search process continues.</p>

            <p>The encodings given to the first and second solver in this architecture are typically specified declaratively, using propositional logic or logic programs. The way in which refinements are produced from counterexamples are mostly given in a procedural way&mdash;e.g., in the form of a subalgorithm that produces a constraint from a counterexample. If these refinements were also specified declaratively&mdash;e.g., by just stating the properties that define them&mdash;the entire algorithm specification could be more readable and easier to modify.</p>

            <p>This research project involves studying to what extent solving search problems at the second level of the PH by declaratively specified CEGAR-style algorithms leads to more readable (and more easily adaptable) encodings, while not giving up too much in terms of algorithmic efficiency.</p>

            <p>There is a <a href="https://github.com/rdehaan/declarative-cegar/">prototype system</a> available, based on answer set programming, that can be used as a starting point.</p>

            <ul>
              <li>This project requires a solid understanding of answer set programming. Students that have taken the course <i>Knowledge Representation and Reasoning</i> at the UvA are well prepared for this.</li>
              <li>The project is algorithmic in nature, and involves some programming in Python.</li>
            </ul>

            <p>&nbsp;</p>

            <h3>3. Arbitrary propositional formulas under answer set semantics</h3>
            <a name="answer-set-semantics"></a>

            <p>Disjunctive answer set programming (dASP) is expressive enough to model search problems at the second level of the Polynomial Hierarchy (PH). Intuitively, these problems can be expressed using an "&exist;&forall;"-quantified statement. However, expressing such problems in dASP typically leads to unnatural (and unreadable) encodings.</p>

            <p>Answer set (or stable model) semantics has also been <a href="https://link.springer.com/article/10.1007/s10472-006-9028-z">defined for arbitrary (propositional) logic formulas</a>&mdash;instead of just for disjunctive logic programs, that can be seen as conjunctions of implications of a particular form. In terms of expressive power and succinctness, disjunctive logic programs and general propositional formulas are equivalent under answer set semantics.</p>

            <p>This research project involves studying to what extent expressing natural search problems at the second level of the PH using general propositional formulas (under answer set semantics) leads to easier-to-understand and more natural encodings.</p>

            <p>Optionally, the project can also include developing (ASP-based) algorithms for general propositional formulas under answer set semantics, and studying whether problems can be solved (more) efficiently using the developed problem encodings.</p>

            <ul>
              <li>This project requires a solid understanding of answer set programming. Students that have taken the course <i>Knowledge Representation and Reasoning</i> at the UvA are well prepared for this.</li>
              <li>This project also requires a basic understanding of computational complexity theory. Students that have taken the course <i>Computational Complexity</i> at the UvA are well prepared for this.</li>
              <li>This project is mostly theoretical in nature, and affinity with logic is recommended.</li>
              <li>This project can also have an algorithmic aspect, which would involve some programming in Python.</li>
            </ul>

            <h3>4. What is needed for a productive completeness theory?</h3>
            <a name="productive-completeness-theory"></a>

            <p>Most settings in which the theory of computational complexity has been used share certain elements. Think, for example, of the framework of NP-completeness. There is a domain of problems (in the example, NP problems), among which there are some efficiently solvable problems, for some notion of efficiency (e.g., the P problems). There is a notion of reductions between problems that is transitive and such that the efficiently solvable problems are closed under these reductions (e.g., polynomial-time many-one reductions). Moreover, the reductions are not so strong that everything in the entire domain is reducable to the efficiently solvable problems (e.g., not everything is trivially reducible to a P problem). There is also typically a natural and useful problem that is complete under the notion of reductions for the entire domain of problems (e.g., SAT is NP-complete). The working hypothesis is that the entire domain of problems is not efficiently solvable (e.g., P &neq; NP), from which it follows that complete problems are not efficiently solvable.</p>

            <p>The following are examples of frameworks where these elements appear (naming only the domain; the efficiently solvable problems; the notion of reduction; and a natural complete problem):</p>
            <ul>
              <li>NP, P, polynomial-time Turing reductions, SAT;</li>
              <li>NP, P, logspace many-one reductions, SAT;</li>
              <li>NL, L, logspace many-one reductions, graph reachability;</li>
              <li>PSPACE, P, polynomial-time many-one reductions, TQBF;</li>
              <li>nucomp-NP, comp-P, nucomp-reductions, &epsilon;-SAT&mdash;see, e.g., <a href="https://www.sciencedirect.com/science/article/pii/S0890540101930433">Cadoli, Donini, Liberatore, Schaerf (2002)</a>;</li>
              <li>computably enumerable sets, computable sets, m-reductions, the diagonal Halting probem;</li>
              <li>PLS, FP, PLS-reductions, Max-Cut/Flip;</li>
              <li>EPT, SUBEPT, serf-reductions, k-SAT;</li>
              <li>#P, FP, poly-time parsimonious reductions, #SAT;</li>
              <li>Learning problems (where solutions can be evaluated efficiently), PAC-learnable problems, PAC-reductions, learning 3DNF formulas;</li>
              <li>W[1], FPT, fpt-reductions, k-Clique;</li>
              <li>Chopped-W[1], fpt-comp-FPT, fpt-comp-reductions, Clique-Completion&mdash;see, e.g., <a href="https://eprints.illc.uva.nl/id/eprint/2210/1/MoL-2022-11.text.pdf">Arteche (2022)</a>;</li>
            </ul>

            <p>Most (but not all) of these settings are remarkably effective, in the sense that they provide a way of classifying for nearly all problems that fit the setting whether or not they fall in the efficiently problems (under the assumption that not all problems in the domain are efficiently solvable, i.e., by showing that the problems are either efficiently solvable or complete for the domain). It is not a priori clear why these frameworks should be so effective.</p>

            <p>Moreover, some of these frameworks lead to a multitude of complete problems, whereas other frameworks only have very few (carefully phrased) complete problems.</p>

            <p>The aim of this project is to provide a starting point for getting a theoretical handle on why these frameworks are so effective, and why some frameworks give more (natural) complete problems than others. The main method for providing such a starting point is to develop a general, high-level, conceptual meta-framework in which all these frameworks can be expressed, and in which one can investigate the similarities and differences between these frameworks.

            <ul>
              <li>This project requires a solid understanding of computational complexity theory. Students that have taken the course <i>Computational Complexity</i> at the UvA are well prepared for this.</li>
              <li>This project is mostly theoretical in nature, and affinity with logic is recommended.</li>
            </ul>

          </div>
        </div>

      </article>
    </div>
  </main>

</body>

</html>
